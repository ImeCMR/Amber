module test_xray_max_likelihood
  use funit
  use xray_pure_utils, only : real_kind
  implicit none
  integer, parameter, private :: rk = real_kind
  real(real_kind), parameter :: tolerance = 1e-5  ! Absolute tolerance

contains
  
  @test
  subroutine test_ml_alpha_beta_in_zones()
    
    use xray_target_max_likelihood_module, only : init_ml => init, finalize_ml => finalize, calc_partial_d_target_d_absFcalc
    use xray_target_max_likelihood_data_module, only: num_ml_resolution_bins, hkl_index_to_ml_resolution_bin, ml_alpha, ml_beta
    use xray_pure_utils, only : calc_resolution, index_partition, index_sort
    
    implicit none
    
    integer, parameter :: n_i = 20
    integer, parameter :: n_j = 20
    integer, parameter :: n_k = 20
    integer, parameter :: N = n_i * n_j * n_k
    integer :: hkl(3, N)
    real(real_kind) :: recip(3, 3)
    
    integer :: n_work
    real(real_kind) :: resolution(N)
    logical :: is_work_flag(N)
    integer :: index(N)
    integer :: reverse_index(N)
    real(real_kind) :: absFobs(N)
    real(real_kind) :: absFcalc(N)
    
    integer :: n_zones
    real(real_kind), allocatable :: expected_bin_alpha(:)
    real(real_kind), allocatable :: expected_bin_beta(:)
    integer, parameter :: unit_num = 15
    
    ! Expected results for regression test
    integer, parameter :: sample_size = 10
    
    integer :: i, j, k
   
    ! Read expected data generated by cctbx
    open (unit=unit_num, file="data/generated/test_ml_alpha_beta_in_zones.txt", action='read' )
    read (unit_num, *) n_zones
    allocate(expected_bin_alpha(n_zones))
    allocate(expected_bin_beta(n_zones))
    read (unit_num, *) expected_bin_alpha
    read (unit_num, *) expected_bin_beta
    close (unit=unit_num)
    
    do i = 1, n_i
      do j = 1, n_j
        do k = 1, n_k
          hkl(:, 1 + (i - 1) * (n_k * n_j) + (j - 1) * (n_k) + (k - 1)) = (/ i, j, k /)
        end do
      end do
    end do
    
    do i = 1, N
      index(i) = i
      reverse_index(i) = i
      absFobs(i) = i
      absFcalc(i) = i * (1 + 0.1_rk * sin(1.0_rk * i))
    end do
    
    ! Orthogonal unit cell (a=10, b=13, c=17)
    recip(:, 1) = (/ 1 / 10.0_rk, 0.0_rk, 0.0_rk /)
    recip(:, 2) = (/ 0.0_rk, 1 / 13.0_rk, 0.0_rk /)
    recip(:, 3) = (/ 0.0_rk, 0.0_rk, 1 / 17.0_rk /)

    resolution = calc_resolution(hkl, recip)
    
    is_work_flag = .TRUE.
    is_work_flag(1:N:10) = .FALSE.
    n_work = count(is_work_flag)
    
    ! Partition reflexes as [WORK|FREE]
    call index_partition(is_work_flag, index)
    ! Sort work set indices by resolution
    call index_sort(resolution, index(:n_work))
    ! Sort test set indices by resolution
    call index_sort(resolution, index(n_work + 1:))
    
    resolution = resolution(index)
    hkl = hkl(:, index)
    absFobs = absFobs(index)
    absFcalc = absFcalc(index)
    reverse_index(index) = reverse_index
    
    call init_ml(resolution, absFobs(n_work + 1:), 1)
    
    @assertEqual(n_zones, num_ml_resolution_bins)
    
    call calc_partial_d_target_d_absFcalc(0, absFobs, absFcalc)
    
    do k = 1, num_ml_resolution_bins
      do j = 1, n_work
        if (hkl_index_to_ml_resolution_bin(j) == k) then
          ! print *, j, hkl(:, j), resolution(j), ml_alpha(j), ml_beta(j), absFobs(j), absFcalc(j), hkl_index_to_ml_resolution_bin(j)
          
          ! expected_* arrayes are stored backwards in cctbx
          @assertEqual(expected_bin_alpha(n_zones - k + 1), ml_alpha(j), tolerance = tolerance)
          @assertEqual(expected_bin_beta(n_zones - k + 1), ml_beta(j), tolerance = tolerance)
          exit
        end if
      end do
    end do
    
    call finalize_ml()
    
    deallocate(expected_bin_alpha)
    deallocate(expected_bin_beta)
  
  end subroutine test_ml_alpha_beta_in_zones
  
  
  @test
  subroutine test_ml_alpha_beta_individual()
    
    use xray_target_max_likelihood_module, only : init_ml => init, finalize_ml => finalize, calc_partial_d_target_d_absFcalc
    use xray_target_max_likelihood_data_module, only: ml_alpha, ml_beta
    use xray_pure_utils, only : calc_resolution, index_partition, index_sort
    
    implicit none
    
    integer, parameter :: n_i = 20
    integer, parameter :: n_j = 20
    integer, parameter :: n_k = 20
    integer, parameter :: N = n_i * n_j * n_k
    integer :: hkl(3, N)
    real(real_kind) :: recip(3, 3)
    
    integer :: n_work
    real(real_kind) :: resolution(N)
    logical :: is_work_flag(N)
    integer :: index(N)
    integer :: reverse_index(N)
    real(real_kind) :: absFobs(N)
    real(real_kind) :: absFcalc(N)
    
    integer :: n_reflexes
    real(real_kind), allocatable :: expected_alpha_individual(:)
    real(real_kind), allocatable :: expected_beta_individual(:)
    integer, parameter :: unit_num = 15
    
    ! Expected results for regression test
    integer, parameter :: sample_size = 10
    
    integer :: i, j, k
    
    ! Read expected data generated by cctbx
    open (unit=unit_num, file="data/generated/test_ml_alpha_beta_individual.txt", action='read')
    read (unit_num, *) n_reflexes
    @assertEqual(N, n_reflexes)
    allocate(expected_alpha_individual(n_reflexes))
    allocate(expected_beta_individual(n_reflexes))
    read (unit_num, *) expected_alpha_individual
    read (unit_num, *) expected_beta_individual
    close (unit=unit_num)
    
    
    do i = 1, n_i
      do j = 1, n_j
        do k = 1, n_k
          hkl(:, 1 + (i - 1) * (n_k * n_j) + (j - 1) * (n_k) + (k - 1)) = (/ i, j, k /)
        end do
      end do
    end do
    
    do i = 1, N
      index(i) = i
      reverse_index(i) = i
      absFobs(i) = i
      absFcalc(i) = i * (1 + 0.1_rk * sin(1.0_rk * i))
    end do
    
    ! Orthogonal unit cell (a=10, b=13, c=17)
    recip(:, 1) = (/ 1 / 10.0_rk, 0.0_rk, 0.0_rk /)
    recip(:, 2) = (/ 0.0_rk, 1 / 13.0_rk, 0.0_rk /)
    recip(:, 3) = (/ 0.0_rk, 0.0_rk, 1 / 13.0_rk /)

    resolution = calc_resolution(hkl, recip)
    
    is_work_flag = .TRUE.
    is_work_flag(1:N:10) = .FALSE.
    n_work = count(is_work_flag)
    
    ! Partition reflexes as [WORK|FREE]
    call index_partition(is_work_flag, index)
    ! Sort work set indices by resolution
    call index_sort(resolution, index(:n_work))
    ! Sort test set indices by resolution
    call index_sort(resolution, index(n_work + 1:))
    
    resolution = resolution(index)
    hkl = hkl(:, index)
    absFobs = absFobs(index)
    absFcalc = absFcalc(index)
    reverse_index(index) = reverse_index
    
    call init_ml(resolution, absFobs(n_work + 1:), 1)
    
    call calc_partial_d_target_d_absFcalc(0, absFobs, absFcalc)
    
    do j = 1, n_work
      i = index(j)
      @assertEqual(expected_alpha_individual(i), ml_alpha(j), tolerance = tolerance)
      @assertEqual(expected_beta_individual(i), ml_beta(j), tolerance = tolerance)
    end do
    
    call finalize_ml()
    
    deallocate(expected_alpha_individual)
    deallocate(expected_beta_individual)
  
  end subroutine test_ml_alpha_beta_individual
  
  @test
  subroutine test_calc_partial_derivative()
    
    use xray_target_max_likelihood_module, only : init_ml => init, finalize_ml => finalize, calc_partial_d_target_d_absFcalc
    use xray_target_max_likelihood_data_module, only: ml_alpha, ml_beta
    use xray_pure_utils, only : calc_resolution, index_partition, index_sort
    
    implicit none
    
    integer, parameter :: n_i = 2
    integer, parameter :: n_j = 3
    integer, parameter :: n_k = 5
    integer, parameter :: N = n_i * n_j * n_k
    integer :: hkl(3, N)
    real(real_kind) :: recip(3, 3)
    
    integer :: n_work
    real(real_kind) :: resolution(N)
    logical :: is_work_flag(N)
    integer :: index(N)
    integer :: reverse_index(N)
    real(real_kind) :: absFobs(N)
    real(real_kind) :: absFcalc(N)
    
    real(real_kind) :: d_absFcalc(N)
    real(real_kind) :: expected_d_absFcalc(N)
    character(len=64) :: message
    
    integer :: i, j, k
    
    do i = 1, n_i
      do j = 1, n_j
        do k = 1, n_k
          hkl(:, 1 + (i - 1) * (n_k * n_j) + (j - 1) * (n_k) + (k - 1)) = (/ i, j, k /)
        end do
      end do
    end do
    
    do i = 1, N
      index(i) = i
      reverse_index(i) = i
      absFobs(i) = i
      absFcalc(i) = i * (1 + 0.1_rk * sin(1.0_rk * i))
    end do
    
    ! Orthogonal unit cell (a=10, b=13, c=17)
    recip(:, 1) = (/ 1 / 10.0_rk, 0.0_rk, 0.0_rk /)
    recip(:, 2) = (/ 0.0_rk, 1 / 13.0_rk, 0.0_rk /)
    recip(:, 3) = (/ 0.0_rk, 0.0_rk, 1 / 17.0_rk /)
    
    resolution = calc_resolution(hkl, recip)
    
    is_work_flag = .TRUE.
    is_work_flag(1:N:10) = .FALSE.
    n_work = count(is_work_flag)
    
    ! Partition reflexes as [WORK|FREE]
    call index_partition(is_work_flag, index)
    ! Sort work set indices by resolution
    call index_sort(resolution, index(:n_work))
    ! Sort test set indices by resolution
    call index_sort(resolution, index(n_work + 1:))
    
    resolution = resolution(index)
    hkl = hkl(:, index)
    absFobs = absFobs(index)
    absFcalc = absFcalc(index)
    reverse_index(index) = reverse_index
    
    call init_ml(resolution, absFobs(n_work + 1:), 1)
    
    call calc_partial_d_target_d_absFcalc(0, absFobs, absFcalc, d_absFcalc)

    expected_d_absFcalc = (/ &
        & -4.0204800408857473, -1.4436037428971520, 0.19675296650202870, -3.0494613886756552, 0.71053872141666630, &
        & -0.61826399206665728, -0.89854106096833541, -3.0323277436972345, 0.61053082760320432, 1.0494514565404471, &
        & -0.54824122068412762, -0.60984632079047296, 0.56414125217955746, -2.7828026797378569, -8.5647849347229993E-002, &
        & -3.7800402757874205E-002, -1.0238906167756554, -1.0898195368527404, -2.0139778686776975, -0.31841913934716848, &
        & 0.38648639494039477, -2.2159323777955988, -1.1259567082236941, 0.14874118972350928, 6.7139177952797488E-002, &
        & -0.34337725069263147, 0.31766977821553849, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000 &
    /)
    
    do i = 1, N
      write(message, *) "Diff at index ", i
      @assertEqual(expected_d_absFcalc(i), d_absFcalc(i), tolerance, message=message)
    end do
    
    @assertEqual(maxval(abs(d_absFcalc(n_work + 1:))), 0.0_real_kind)
    
    call finalize_ml()
  
  end subroutine test_calc_partial_derivative
  
end module test_xray_max_likelihood


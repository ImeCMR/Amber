#!/bin/python
#AUTOGENERATE CODE to create pairs_calc_ti_AUTO.i

f = open('pairs_calc_ti_AUTO.i', 'w')
f.write('! NOTE: This code is autogenerated by ti_code2.py, do not edit this file\n')
pair =  ['linear_V0', 'linear_V1' ,'sc_common_V0', 'sc_common_V1', 'sc_sc_V0', 'sc_sc_V1' ]
cut = ['cut1','cut2']
ctype = ['mefv','efv','fv','f']
vac = ['_vac','']

# ti_eed.i
def ti_eed_i(ti_region, f_pair_idx, f_cut_idx, f_ctype_idx):
  if (pair[f_pair_idx] == 'linear_V0' or pair[f_pair_idx] == 'linear_V1'):
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write('      ti_pot_elect_stk(%(tireg)d) = ti_pot_elect_stk(%(tireg)d) + b0\n'%{'tireg': ti_region})
    f.write("""
      ele_weight = ti_item_weights(4,%(tireg)d)
      df = b1 * delr2inv
      df = df * ele_weight
"""%{'tireg': ti_region})
    if ('v' in ctype[f_ctype_idx]): #NEED_VIR
      f.write('      eedvir_stk_sc(%(tireg)d) = eedvir_stk_sc(%(tireg)d) - df * delr2\n'%{'tireg': ti_region})
    if ('m' in ctype[f_ctype_idx]): #NEED_MBAR
      f.write("""
        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(%(tireg)d,bar_i,4) - ele_weight)
        end do
"""%{'tireg': ti_region})
  elif (pair[f_pair_idx] == 'sc_common_V0' or pair[f_pair_idx] == 'sc_common_V1'):
    f.write("""
      ele_weight = ti_item_weights(5,%(tireg)d)
      if(gti_ele_sc .eq. 1) then
          ele_dweight = ti_item_dweights(5,%(tireg)d)
      else
          ele_dweight = ti_item_dweights(1,%(tireg)d)
      end if
      delr_n = delr ** (sceeorder)

      if(gti_ele_sc .eq. 1) then
        denom = 1.0d0 / ( delr_n + scbeta * &
          (1.0d0 - ele_weight) ) ** sceeorderinv
      else
        denom = 1.0d0 / ( delr_n + scbeta * &
          (1.0d0 - ti_item_weights(1,%(tireg)d)) ) ** sceeorderinv
      end if
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          
"""%{'tireg': ti_region})
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write("""
      !cgi_cgj * delrinv          
      ti_pot_elect_stk(%(tireg)d) = ti_pot_elect_stk(%(tireg)d) + &
        (switch * denom)
      sc_dvdl_elect_stk(%(tireg)d) = sc_dvdl_elect_stk(%(tireg)d)+&
        (switch * denom_n * scbeta * ele_dweight * sceeorderinv)
"""%{'tireg': ti_region})
    f.write("""
      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ele_weight

      !correct eedvir -- add contribution from softcore force
"""%{'tireg': ti_region})   
    if ('v' in ctype[f_ctype_idx]): #NEED_VIR
      f.write('      eedvir_stk_sc(%(tireg)d) = eedvir_stk_sc(%(tireg)d) - df * delr2\n'%{'tireg': ti_region})
    if ('m' in ctype[f_ctype_idx]): #NEED_MBAR
      f.write("""
        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ele_weight
        end do
        do bar_i = 1, bar_states
          if(gti_ele_sc .eq. 1) then
            denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
              bar_lambda(%(tireg)d,bar_i,5) ) ) ** sceeorderinv
            bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
              bar_lambda(%(tireg)d,bar_i,5)
          else
            denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
              bar_lambda(%(tireg)d,bar_i,1) ) ) ** sceeorderinv
            bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
              bar_lambda(%(tireg)d,bar_i,5)
          end if
        end do
"""%{'tireg': ti_region})    
  elif (pair[f_pair_idx] == 'sc_sc_V0' or pair[f_pair_idx] == 'sc_sc_V1'):
    f.write('      df = b1 * delr2inv\n')
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write("""
       ele_weight = ti_item_weights(5,%(tireg)d)
       ele_dweight = ti_item_dweights(5,%(tireg)d)
       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(%(tireg)d) = &
         ti_pot_elect_stk(%(tireg)d) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(%(tireg)d) = &
         sc_elect_stk(%(tireg)d) + cgi_cgj * delrinv
"""%{'tireg': ti_region})
    f.write("""
      ele_weight = ti_item_weights(5,%(tireg)d)
      ele_dweight = ti_item_dweights(5,%(tireg)d)
      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ele_weight

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
"""%{'tireg': ti_region})
    if ('v' in ctype[f_ctype_idx]): #NEED_VIR
      f.write('    eedvir_stk_sc(%(tireg)d) = eedvir_stk_sc(%(tireg)d) - df * delr2\n'%{'tireg': ti_region})
    if ('m' in ctype[f_ctype_idx]): #NEED_MBAR
      f.write("""
        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(%(tireg)d,bar_i,5) - ti_item_weights(5,%(tireg)d))
        end do
"""%{'tireg': ti_region})

# END ti_eed.i


# ti_vdw.i
def ti_vdw_i(ti_region, f_pair_idx, f_cut_idx, f_ctype_idx):
  if (pair[f_pair_idx] == 'linear_V0' or pair[f_pair_idx] == 'linear_V1'):
    f.write("""
    vdw_weight = ti_item_weights(6,%(tireg)d)
    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
"""%{'tireg': ti_region})  
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write("""
    ti_pot_vdw_stk(%(tireg)d) = ti_pot_vdw_stk(%(tireg)d) + (f12 - f6)
"""%{'tireg': ti_region})     
    f.write('    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * vdw_weight\n'%{'tireg': ti_region})
    if ('m' in ctype[f_ctype_idx]): #NEED_MBAR
      f.write("""
          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) + (f12 - f6) * &
              (bar_lambda(%(tireg)d,bar_i,6) - vdw_weight)
          end do
"""%{'tireg': ti_region})
  elif (pair[f_pair_idx] == 'sc_common_V0' or pair[f_pair_idx] == 'sc_common_V1'):  
    f.write("""
    vdw_weight = ti_item_weights(6,%(tireg)d)
    if(gti_vdw_sc .eq. 1) then
        vdw_dweight = ti_item_dweights(6,%(tireg)d)
    else
        vdw_dweight = ti_item_dweights(1,%(tireg)d)
    end if
    r6 = delr2 * delr2 * delr2
    if(gti_vdw_sc .eq. 1) then
        f6 = 1.0d0/(scalpha*(1.0d0-vdw_weight)+r6*ti_sigma6(ic))
    else
        f6 = 1.0d0/(scalpha*(1.0d0-ti_item_weights(1,%(tireg)d))+r6*ti_sigma6(ic))
    end if
    f12 = f6 * f6
"""%{'tireg': ti_region})
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write("""

    ti_pot_vdw_stk(%(tireg)d) = ti_pot_vdw_stk(%(tireg)d) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(%(tireg)d) = sc_dvdl_vdw_stk(%(tireg)d) + &
      ti_foureps(ic)*scalpha*vdw_dweight*f12*(2.0d0*f6-1.0d0) 
"""%{'tireg': ti_region})
    f.write("""
    df = df + vdw_weight * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)
"""%{'tireg': ti_region})        
    if ('m' in ctype[f_ctype_idx]): #NEED_MBAR
      f.write("""
          do bar_i = 1, bar_states
             bar_cont(bar_i) = bar_cont(bar_i) - &
               ti_foureps(ic) * ( f12 - f6 ) * vdw_weight
          end do
          do bar_i = 1, bar_states
            if(gti_vdw_sc .eq. 1) then
              f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(%(tireg)d,bar_i,6)) + &
                r6 * ti_sigma6(ic) )
            else
              f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(%(tireg)d,bar_i,1)) + &
                r6 * ti_sigma6(ic) )
            end if
            f12 = f6 * f6
             bar_cont(bar_i) = bar_cont(bar_i) + &
               ti_foureps(ic) * (f12 - f6) * bar_lambda(%(tireg)d,bar_i,6)
          end do
"""%{'tireg': ti_region})  
  elif (pair[f_pair_idx] == 'sc_sc_V0' or pair[f_pair_idx] == 'sc_sc_V1'):
    f.write("""
    vdw_weight = ti_item_weights(6,%(tireg)d)
    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
"""%{'tireg': ti_region})
    if ('e' in ctype[f_ctype_idx]): #NEED_ENE
      f.write('    sc_vdw_stk(%(tireg)d) = sc_vdw_stk(%(tireg)d) + ( f12 - f6 )\n'%{'tireg': ti_region})
    f.write('    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv\n')
    
#END ti_vdw.i    
    
# Now loop over all possible functions and write to pairs_calc_ti_AUTO.i    
for f_pair_idx in xrange(0,len(pair)):
  for f_cut_idx in xrange(0,len(cut)):
    for f_ctype_idx in xrange(0,len(ctype)):
      for f_vac_idx in xrange(0,len(vac)):
        ti_region = int(pair[f_pair_idx][-1]) + 1
        f.write('subroutine pairs_calc_ti_%s_%s_%s%s'%(pair[f_pair_idx],cut[f_cut_idx],ctype[f_ctype_idx],vac[f_vac_idx]))
        f.write('(img_crd, img_qterm, ef_tbl, & \need_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)\n')
        f.write("""
  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = int(Z"07FFFFFF")
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  double precision      :: vdw_weight, vdw_dweight, ele_weight, ele_dweight
 
  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
""")
        if (cut[f_cut_idx] == 'cut2'):
          f.write('     if (delr2 .lt. es_cut2) then\n')
        else:
          f.write('    if (delr2 .lt. max_nb_cut2) then\n')
        f.write("""

      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)
""")

        if (vac[f_vac_idx] == '_vac'):
          f.write('      switch = 1.0\n')
          f.write('      d_switch_dx = 1.0\n')
        else:
          f.write('      switch = eed_cub(1 + ind) + &\n')
          f.write('               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))\n')
          f.write('      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2\n')

        f.write("""
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
""")
        # #include "ti_eed.i"
        ti_eed_i(ti_region, f_pair_idx, f_cut_idx, f_ctype_idx)
        f.write("""     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df
""")
        if ('v' in ctype[f_ctype_idx]): #NEED_VIR
          f.write("""
      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz
""")
        f.write("""
      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(%(tireg)d, 1, img_j) = &
        ti_img_frc(%(tireg)d, 1, img_j) + dfx
      ti_img_frc(%(tireg)d, 2, img_j) = &
        ti_img_frc(%(tireg)d, 2, img_j) + dfy
      ti_img_frc(%(tireg)d, 3, img_j) = &
        ti_img_frc(%(tireg)d, 3, img_j) + dfz
"""%{'tireg': ti_region})        
        f.write("""

    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
""")
        if (cut[f_cut_idx] == 'cut2'):
          f.write('      if (delr2 .lt. es_cut2) then\n')
        f.write("""

      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)
""")
        if (vac[f_vac_idx] == '_vac'):
          f.write('      switch = 1.0\n')
          f.write('      d_switch_dx = 1.0\n')
        else:
          f.write('      switch = eed_cub(1 + ind) + &\n')
          f.write('               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))\n')
          f.write('      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2\n')

        f.write("""
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
""")
        # #include "ti_eed.i"
        ti_eed_i(ti_region, f_pair_idx, f_cut_idx, f_ctype_idx)
        if (cut[f_cut_idx] == 'cut2'):
          f.write("""
      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if
""")      
        ti_vdw_i(ti_region, f_pair_idx, f_cut_idx, f_ctype_idx)
        f.write("""
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df
""")
        if ('v' in ctype[f_ctype_idx]): #NEED_VIR
          f.write("""
      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz
""")
        f.write("""
      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(%(tireg)d, 1, img_j) = &
        ti_img_frc(%(tireg)d, 1, img_j) + dfx
      ti_img_frc(%(tireg)d, 2, img_j) = &
        ti_img_frc(%(tireg)d, 2, img_j) + dfy
      ti_img_frc(%(tireg)d, 3, img_j) = &
        ti_img_frc(%(tireg)d, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(%(tireg)d, 1, img_i) = ti_img_frc(%(tireg)d, 1, img_i) - dumx
  ti_img_frc(%(tireg)d, 2, img_i) = ti_img_frc(%(tireg)d, 2, img_i) - dumy
  ti_img_frc(%(tireg)d, 3, img_i) = ti_img_frc(%(tireg)d, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
"""%{'tireg': ti_region})
        f.write('end subroutine pairs_calc_ti_%s_%s_%s%s\n'%(pair[f_pair_idx],cut[f_cut_idx],ctype[f_ctype_idx],vac[f_vac_idx]))


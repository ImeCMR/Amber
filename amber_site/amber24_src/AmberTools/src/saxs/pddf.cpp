#include <cmath>
#include <vector>
#include "saxsDS.h"
#include "pddf.h"
#include "dx.h"
#include "atm_f.h"
#include "pdb.h"

/////////////////////////////////////////////////////////////////
// Compute electron density generated by an atom from a distance
/////////////////////////////////////////////////////////////////
double smearing_e (const coordinate &atom,
                   const dx_type &dx,
                   int index,
                   size_t split,
                   const std::vector<coeff_f> &F_table) {
    coordinate origin = dx_1Dindex2coord (dx, index);
    double result = 0;
    for (size_t x = 0; x < split; x++)
        for (size_t y = 0; y < split; y++)
            for (size_t z = 0; z < split; z++) {
                // Center of a small voxel
                double centerx = origin.x + (x+0.5)/split*dx.delta[0];
                double centery = origin.y + (y+0.5)/split*dx.delta[1];
                double centerz = origin.z + (z+0.5)/split*dx.delta[2];
                double dist_sqr = (centerx-atom.x)*(centerx-atom.x) + (centery-atom.y)*(centery-atom.y) + (centerz-atom.z)*(centerz-atom.z);
                result += atom_rho (atom.type, dist_sqr, F_table);
            }
    return result/(split*split*split);
}

/////////////////////////////////////////////////////////////
// Distribute electrons of an atom to neighboring grid points
/////////////////////////////////////////////////////////////
void distributing_e (const coordinate &atom,
                     dx_type &dx,
                     double smear_cut,
                     double anom_f,
                     const std::vector<coeff_f> &F_table) {
    int stepx = floor (smear_cut / dx.delta[0]);
    int stepy = floor (smear_cut / dx.delta[1]);
    int stepz = floor (smear_cut / dx.delta[2]);

    int x_atom = floor((atom.x - dx.origin[0]) / dx.delta[0]);
    int y_atom = floor((atom.y - dx.origin[1]) / dx.delta[1]);
    int z_atom = floor((atom.z - dx.origin[2]) / dx.delta[2]);

    double sum = 0;
    for (int x = -stepx; x <= stepx; x++)
        for (int y = -stepy; y <= stepy; y++)
            for (int z = -stepz; z <= stepz; z++) {
                if ((x == 0) and (y == 0) and (z == 0))
                    continue;
                int index = dx_3Dindex_to_1Dindex (dx, x_atom+x, y_atom+y, z_atom+z);
                double rho_e = smearing_e (atom, dx, index, 2, F_table);
                if ((index >= 0) and (index < dx.value.size()))
                    #pragma omp atomic
                    dx.value[index] += rho_e;
                sum += rho_e;
            }

    size_t index_center = dx_3Dindex_to_1Dindex (dx, x_atom, y_atom, z_atom);
    double remain = count_e (atom.type, anom_f) / (dx.delta[0] * dx.delta[1] * dx.delta[2]) - sum;
    #pragma omp atomic
        dx.value[index_center] += remain;
}

///////////////////////////////////////////////
// Compute bulk value of the electron density
/////////////////////////////////////////////
double calc_bulk_rho_e (const dx_type &dx,
                        const coordinate &max_bulk,
                        const coordinate &min_bulk) {
    double sum = 0;
    double sum_total = 0;
    size_t count = 0;
    size_t count_total = 0;

    #pragma omp parallel for reduction (+:sum, sum_total, count_total, count) collapse (3)
    // Leave the edge grids out
    for (size_t x = 1; x < dx.ngrid[0] - 1; x++)
        for (size_t y = 1; y < dx.ngrid[1] - 1; y++)
            for (size_t z = 1; z < dx.ngrid[2] - 1; z++) {
                size_t index = dx_3Dindex_to_1Dindex (dx, x, y, z);
                sum_total += dx.value[index];
                count_total++;
                coordinate grid = dx_1Dindex2coord (dx, index);
                if ((grid.x > min_bulk.x) and (grid.x < max_bulk.x) and\
                    (grid.y > min_bulk.y) and (grid.y < max_bulk.y) and\
                    (grid.z > min_bulk.z) and (grid.z < max_bulk.z)) {
                    sum += dx.value[index];
                    count++;
                }
            }
    return (sum_total - sum) / (count_total - count);
}

/*double calc_bulk_rho_e (const std::vector< std::vector<coordinate> > &snapshot,
                        const coordinate &max_bulk,
                        const coordinate &min_bulk,
                        double anom_f) {
    coordinate max_box, min_box;
    maxmin_coord_traj (snapshot, max_box, min_box);
    double sum_rho_e = 0;
    double volume = (max_box.x - min_box.x - 2.)*(max_box.y - min_box.y - 2.)*(max_box.z - min_box.z - 2.) -\
                    (max_bulk.x - min_bulk.x)*(max_bulk.y - min_bulk.y)*(max_bulk.z - min_bulk.z);

    // Compute the electron density within those two regions
    #pragma omp parallel for shared (max_box, min_box, anom_f, volume) reduction(+:sum_rho_e)
    for (size_t i = 0; i < snapshot.size(); i++) {
        double sum_e = 0;

        for (size_t j = 0; j < snapshot[i].size(); j++) {
            if (snapshot[i][j].x < min_box.x + 1.) continue;
            if (snapshot[i][j].y < min_box.y + 1.) continue;
            if (snapshot[i][j].z < min_box.z + 1.) continue;

            if (snapshot[i][j].x > max_box.x - 1.) continue;
            if (snapshot[i][j].y > max_box.y - 1.) continue;
            if (snapshot[i][j].z > max_box.z - 1.) continue;

            if ((snapshot[i][j].x < max_bulk.x) and (snapshot[i][j].x > min_bulk.x) and \
                (snapshot[i][j].y < max_bulk.y) and (snapshot[i][j].y > min_bulk.y) and \
                (snapshot[i][j].z < max_bulk.z) and (snapshot[i][j].z > min_bulk.z)) continue;

            double e = count_e (snapshot[i][j].type, anom_f);
            sum_e += e;
        }
        double rho_e = sum_e / volume;
        sum_rho_e += rho_e;
    }

    return sum_rho_e / snapshot.size();
}

///////////////////////////////////////////////////////////////////////
// Precalculate electron distribution around nucleus for a solvent atom
///////////////////////////////////////////////////////////////////////
vector<double> smearing_e_solv (const dx_type &dx,
                                int stepx, int stepy, int stepz,
                                double smear_cut,
                                const vector<double> &e_rdf_wat,
                                double rdf_dr,
                                const vector<coeff_f2> &F_table2) {
    vector<double> result;
    result.resize ((2*stepx+1) * (2*stepy+1) * (2*stepz+1), 0);
    double sum = 0;
    for (int i = -stepx; i <= stepx; i++)
        for (int j = -stepy; j <= stepy; j++)
            for (int k = -stepz; k <= stepz; k++) {
                if ((i == 0) and (j == 0) and (k == 0))
                    continue;
                double deltax = i*dx.delta[0];
                double deltay = j*dx.delta[1];
                double deltaz = k*dx.delta[2];
                double dist_sqr = deltax*deltax + deltay*deltay + deltaz*deltaz;
                if (dist_sqr <= smear_cut*smear_cut) {
                    int index = (i+stepx)*(2*stepy+1)*(2*stepz+1) + (j+stepy)*(2*stepz+1) + (k+stepz);
                    double eden = 0;
                    if (dx.type == "Ow") {
                        int rdf_index = floor(sqrt(dist_sqr) / rdf_dr);
                        if (rdf_index < e_rdf_wat.size())
                            eden = e_rdf_wat[rdf_index];
                    } else if (dx.type != "Hw")
                        eden = atom_rho (dx.type, dist_sqr, F_table2);

                    result[index] = eden * dx.delta[0] * dx.delta[1] * dx.delta[2];
                    sum += result[index];
                }
            }

    double total_e;
    if ((dx.type == "Ow") or (dx.type == "Na+") or (dx.type == "Mg2+"))
        total_e = 10;
    else if (dx.type == "Cl-")
        total_e = 18;
    else if ((dx.type == "Rb+") or (dx.type == "Sr2+") or (dx.type == "Br-"))
        total_e = 36;
    else {
        cout << "Unable to recognize grid of " << dx.type << endl;
        exit (0);
    }

    size_t index_center = stepx*(2*stepy+1)*(2*stepz+1) + stepy*(2*stepz+1) + stepz;    
    result[index_center] = total_e - sum;

    return result;
}

//////////////////////////////////////////////////////
// Generate an excess electron density map of solvent
//////////////////////////////////////////////////////
dx_type solvent_excess_e_map (const dx_type &dx,
                              const vector<list_cutoff> &list_hyd,
                              double smear_cut,
                              const vector<double> &e_rdf_wat,
                              double rdf_dr,
                              const vector<coeff_f2> &F_table2) {
    dx_type result;
    result.type = dx.type + "_ex";
    result.ngrid = dx.ngrid; result.origin = dx.origin;   result.delta = dx.delta;
    result.value.resize (dx.value.size(), 0);

    int stepx = floor (smear_cut / dx.delta[0]);
    int stepy = floor (smear_cut / dx.delta[1]);
    int stepz = floor (smear_cut / dx.delta[2]);

    vector<double> prior_grid = smearing_e_solv (dx, stepx, stepy, stepz, smear_cut, e_rdf_wat, rdf_dr, F_table2);

    #pragma omp parallel for schedule (dynamic, 1000) shared (result, prior_grid, stepx, stepy, stepz)
    for (size_t i = 0; i < list_hyd.size(); i++) {
        if ((dx.value[list_hyd[i].index] > 0.99999) and (dx.value[list_hyd[i].index] < 1.00001))
            continue;
        int x_center = floor (list_hyd[i].index/(dx.ngrid[1]*dx.ngrid[2]));
        int y_center = floor ((list_hyd[i].index - x_center*dx.ngrid[1]*dx.ngrid[2]) / dx.ngrid[2]);
        int z_center = list_hyd[i].index - x_center*dx.ngrid[1]*dx.ngrid[2] - y_center*dx.ngrid[2];
        for (int x = -stepx; x <= stepx; x++)
            for (int y = -stepy; y <= stepy; y++)
                for (int z = -stepz; z <= stepz; z++) {
                    int x_index = x_center + x;
                    int y_index = x_center + y;
                    int z_index = z_center + z;
                    if ((x_index < 0) or (x_index >= dx.ngrid[0]) or \
                        (y_index < 0) or (y_index >= dx.ngrid[1]) or \
                        (z_index < 0) or (z_index >= dx.ngrid[2]))
                        continue;
                    size_t grid_index = dx_3Dindex_to_1Dindex (dx, x_index, y_index, z_index);
                    int prior_grid_index = (x+stepx)*(2*stepy+1)*(2*stepz+1) + (y+stepy)*(2*stepz+1) + (z+stepz);
                    if (prior_grid[prior_grid_index] > 1e-5)
                        #pragma omp critical
                        result.value[grid_index] += prior_grid[prior_grid_index] * (dx.value[list_hyd[i].index] - 1);
                }
    }
    #pragma omp parallel for shared (result)
    for (size_t i = 0; i < list_hyd.size(); i++)
        result.value[list_hyd[i].index] *= AVOGADRO * 1e-27 * dx.conc;

    return result;
}*/

///////////////////////////////////////////////
// Compute the PDDF between solvent and solute
///////////////////////////////////////////////
std::vector<double> calc_pddf (const dx_type &dx1,
                               const std::vector<list_cutoff> &list1,
                               const dx_type &dx2,
                               const std::vector<list_cutoff> &list2,
                               double cutoff,
                               double dr) {
    std::vector<double> result;
    result.resize (floor (cutoff/dr), 0);

    #pragma omp parallel for schedule (dynamic, 1000) shared (result, cutoff, dr) collapse (2)
    for (size_t i = 0; i < list1.size(); i++)
        for (size_t j = 0; j < list2.size(); j++) {
            double dist = grid2grid_dist (dx1, list1[i].index, list2[j].index);
            if (dist <= cutoff) {
                size_t index = floor (dist/dr);
                double gain = dx1.value[list1[i].index] * dx2.value[list2[j].index];
                #pragma omp atomic
                    result[index] += gain;
            }
        }
    return result;
}
